"use strict";var x=Object.defineProperty;var U=(e,t,n)=>t in e?x(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var S=(e,t,n)=>U(e,typeof t!="symbol"?t+"":t,n);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const $=require("url"),W=require("buffer"),q=require("http"),i=require("./index-B-kSrMS1.js"),A=require("./index-AQefyu2b.js");function p(e){return new Promise((t,n)=>{var a;const r=q.request({method:"GET",...e,hostname:(a=e.hostname)==null?void 0:a.replace(/^\[(.+)\]$/,"$1")});r.on("error",o=>{n(Object.assign(new i.ProviderError("Unable to connect to instance metadata service"),o)),r.destroy()}),r.on("timeout",()=>{n(new i.ProviderError("TimeoutError from instance metadata service")),r.destroy()}),r.on("response",o=>{const{statusCode:f=400}=o;(f<200||300<=f)&&(n(Object.assign(new i.ProviderError("Error response received from instance metadata service"),{statusCode:f})),r.destroy());const s=[];o.on("data",l=>{s.push(l)}),o.on("end",()=>{t(W.Buffer.concat(s)),r.destroy()})}),r.end()})}const P=e=>!!e&&typeof e=="object"&&typeof e.AccessKeyId=="string"&&typeof e.SecretAccessKey=="string"&&typeof e.Token=="string"&&typeof e.Expiration=="string",y=e=>({accessKeyId:e.AccessKeyId,secretAccessKey:e.SecretAccessKey,sessionToken:e.Token,expiration:new Date(e.Expiration),...e.AccountId&&{accountId:e.AccountId}}),R=1e3,b=0,N=({maxRetries:e=b,timeout:t=R})=>({maxRetries:e,timeout:t}),h=(e,t)=>{let n=e();for(let r=0;r<t;r++)n=n.catch(e);return n},T="AWS_CONTAINER_CREDENTIALS_FULL_URI",m="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",C="AWS_CONTAINER_AUTHORIZATION_TOKEN",K=(e={})=>{const{timeout:t,maxRetries:n}=N(e);return()=>h(async()=>{const r=await z({logger:e.logger}),a=JSON.parse(await B(t,r));if(!P(a))throw new i.CredentialsProviderError("Invalid response received from instance metadata service.",{logger:e.logger});return y(a)},n)},B=async(e,t)=>(process.env[C]&&(t.headers={...t.headers,Authorization:process.env[C]}),(await p({...t,timeout:e})).toString()),G="169.254.170.2",H={localhost:!0,"127.0.0.1":!0},j={"http:":!0,"https:":!0},z=async({logger:e})=>{if(process.env[m])return{hostname:G,path:process.env[m]};if(process.env[T]){const t=$.parse(process.env[T]);if(!t.hostname||!(t.hostname in H))throw new i.CredentialsProviderError(`${t.hostname} is not a valid container metadata service hostname`,{tryNextLink:!1,logger:e});if(!t.protocol||!(t.protocol in j))throw new i.CredentialsProviderError(`${t.protocol} is not a valid container metadata service protocol`,{tryNextLink:!1,logger:e});return{...t,port:t.port?parseInt(t.port,10):void 0}}throw new i.CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${m} or ${T} environment variable is set`,{tryNextLink:!1,logger:e})};class g extends i.CredentialsProviderError{constructor(n,r=!0){super(n,r);S(this,"tryNextLink");S(this,"name","InstanceMetadataV1FallbackError");this.tryNextLink=r,Object.setPrototypeOf(this,g.prototype)}}exports.Endpoint=void 0;(function(e){e.IPv4="http://169.254.169.254",e.IPv6="http://[fd00:ec2::254]"})(exports.Endpoint||(exports.Endpoint={}));const J="AWS_EC2_METADATA_SERVICE_ENDPOINT",X="ec2_metadata_service_endpoint",Y={environmentVariableSelector:e=>e[J],configFileSelector:e=>e[X],default:void 0};var I;(function(e){e.IPv4="IPv4",e.IPv6="IPv6"})(I||(I={}));const Z="AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",Q="ec2_metadata_service_endpoint_mode",ee={environmentVariableSelector:e=>e[Z],configFileSelector:e=>e[Q],default:I.IPv4},F=async()=>A.parseUrl(await te()||await ne()),te=async()=>A.loadConfig(Y)(),ne=async()=>{const e=await A.loadConfig(ee)();switch(e){case I.IPv4:return exports.Endpoint.IPv4;case I.IPv6:return exports.Endpoint.IPv6;default:throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(I)}`)}},re=5*60,ae=5*60,oe="https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html",D=(e,t)=>{const n=re+Math.floor(Math.random()*ae),r=new Date(Date.now()+n*1e3);t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(r)}.
For more information, please visit: `+oe);const a=e.originalExpiration??e.expiration;return{...e,...a?{originalExpiration:a}:{},expiration:r}},se=(e,t={})=>{const n=(t==null?void 0:t.logger)||console;let r;return async()=>{let a;try{a=await e(),a.expiration&&a.expiration.getTime()<Date.now()&&(a=D(a,n))}catch(o){if(r)n.warn("Credential renew failed: ",o),a=D(r,n);else throw o}return r=a,a}},L="/latest/meta-data/iam/security-credentials/",ie="/latest/api/token",v="AWS_EC2_METADATA_V1_DISABLED",O="ec2_metadata_v1_disabled",M="x-aws-ec2-metadata-token",ce=(e={})=>se(de(e),{logger:e.logger}),de=(e={})=>{let t=!1;const{logger:n,profile:r}=e,{timeout:a,maxRetries:o}=N(e),f=async(s,l)=>{var w;if(t||((w=l.headers)==null?void 0:w[M])==null){let c=!1,d=!1;const k=await A.loadConfig({environmentVariableSelector:E=>{const u=E[v];if(d=!!u&&u!=="false",u===void 0)throw new i.CredentialsProviderError(`${v} not set in env, checking config file next.`,{logger:e.logger});return d},configFileSelector:E=>{const u=E[O];return c=!!u&&u!=="false",c},default:!1},{profile:r})();if(e.ec2MetadataV1Disabled||k){const E=[];throw e.ec2MetadataV1Disabled&&E.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"),c&&E.push(`config file profile (${O})`),d&&E.push(`process environment variable (${v})`),new g(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${E.join(", ")}].`)}}const V=(await h(async()=>{let c;try{c=await Ee(l)}catch(d){throw d.statusCode===401&&(t=!1),d}return c},s)).trim();return h(async()=>{let c;try{c=await fe(V,l,e)}catch(d){throw d.statusCode===401&&(t=!1),d}return c},s)};return async()=>{const s=await F();if(t)return n==null||n.debug("AWS SDK Instance Metadata","using v1 fallback (no token fetch)"),f(o,{...s,timeout:a});{let l;try{l=(await le({...s,timeout:a})).toString()}catch(_){if((_==null?void 0:_.statusCode)===400)throw Object.assign(_,{message:"EC2 Metadata token request returned error"});return(_.message==="TimeoutError"||[403,404,405].includes(_.statusCode))&&(t=!0),n==null||n.debug("AWS SDK Instance Metadata","using v1 fallback (initial)"),f(o,{...s,timeout:a})}return f(o,{...s,headers:{[M]:l},timeout:a})}}},le=async e=>p({...e,path:ie,method:"PUT",headers:{"x-aws-ec2-metadata-token-ttl-seconds":"21600"}}),Ee=async e=>(await p({...e,path:L})).toString(),fe=async(e,t,n)=>{const r=JSON.parse((await p({...t,path:L+e})).toString());if(!P(r))throw new i.CredentialsProviderError("Invalid response received from instance metadata service.",{logger:n.logger});return y(r)};exports.DEFAULT_MAX_RETRIES=b;exports.DEFAULT_TIMEOUT=R;exports.ENV_CMDS_AUTH_TOKEN=C;exports.ENV_CMDS_FULL_URI=T;exports.ENV_CMDS_RELATIVE_URI=m;exports.fromContainerMetadata=K;exports.fromInstanceMetadata=ce;exports.getInstanceMetadataEndpoint=F;exports.httpRequest=p;exports.providerConfigFromInit=N;
//# sourceMappingURL=index-BSf0nwMX.js.map
